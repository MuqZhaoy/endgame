# 自适应 KVCache 量化方案文档

## 1. 目标

减少 KVCache 的内存占用，同时尽量减小对模型性能（如准确率、困惑度）的影响。

## 2. 核心步骤

对 KVCache Tensor 中的浮点数值进行处理，将其转换为较低比特数的表示，并能在需要时近似地恢复回浮点数。该方案包含以下关键步骤：

*   **确定量化单元与粒度:**
    *   选择基础量化级别 (`token`, `layer`, `head`)，定义基础的量化参数共享范围。
    *   在此基础上，引入 **特征维度上的分组**。将基础单元（如一个 head）的 `embed_size_per_head` 维度划分为若干个特征组（由 `group_size` 定义）。量化参数（如 `scale`, `mean`）和/或量化比特数可以在这些特征组之间变化。
    *   `quantize_dims` 参数定义了单元间共享和单元内分组的维度。

*   **处理离群点:**
    *   在计算量化参数前，识别并标记数据中的极端值（基于 `outliers_ratio`）。
    *   这些离群点不参与后续的归一化和量化映射步骤，以原始精度保留。
    *   离群点可以在整个基础单元（如 head）或在每个特征组内部独立计算。
    *   核心目的：防止异常值影响主流量化精度。

*   **特征重要性评估:**
    *   **目的:** 识别 `embed_size_per_head` 维度中对模型性能贡献更大的特征（或特征组）。
    *   **方法:**
        *   **静态:** 通过离线分析（如基于校准集的激活值方差、梯度信息等）预计算特征重要性分数。
        *   **动态:** 在运行时根据当前上下文的统计数据（如特征幅值、方差等）评估重要性。
    *   **应用:** 评估出的重要性指导后续的归一化、比特分配和量化映射，为重要特征分配更多资源。

*   **数值归一化/标准化:**
    *   将**非离群点**的数值映射到标准范围。
    *   `mean_value` 和 `scale_value` **为每个特征组独立计算**。
    *   对称/非对称 (`symmetric`) 和 MinMax/Std (`method`) 的选择应用于特征组级别。
    *   核心目的：在特征组级别进行归一化，反映局部数据特性，并允许基于重要性进行差异化处理。参数按特征组存储。

*   **映射到量化值:**
    *   将归一化后的值映射到低比特表示。
    *   **可用方法:**
        *   **均匀量化 (`_uniform_quantize`):** 假设特征组内归一化数据均匀分布，进行线性映射和四舍五入。
        *   **正态量化 (`_normal_quantize`):** 假设特征组内归一化数据服从标准正态分布，使用预计算或动态计算的正态分布分位数进行映射。
        *   **自适应分布量化 (`_adaptive_quantize`):**
            *   对每个特征组内的归一化数据，估计其**经验累积分布函数 (Empirical CDF)** 或计算分位数。
            *   根据实际观测到的分布确定量化边界和中心点（centroids），以最小化实际数据分布下的量化误差。
            *   核心思想：量化方案匹配局部数据的真实分布。
    *   **结合特征重要性:**
        *   不同的特征组可根据其重要性分配不同的**量化比特数 (`n_bits`)**。
        *   即使比特数相同，重要特征组的量化参数可能设计得更精细。

*   **反量化/恢复:**
    *   使用**对应特征组**存储的 `scale` 和 `mean`（以及可能的量化中心点），将量化值恢复为近似的浮点数。
    *   `denormalized_value = quantized_value * scale_group + mean_group`

*   **整合结果:**
    *   将所有特征组的反量化结果与对应区域的离群点（以原始精度存储）合并，得到最终的 KVCache。

*   **(可选) 动态比特数分配:**
    *   如果启用 (`use_attentions=True`)，目标是根据预设的误差容忍度 (`target_quantization_error`) 动态决定比特数。
    *   误差估计考虑 **Attention 权重** 和 **特征维度** 的影响。
    *   计算出的比特数预算首先在基础单元（如 head）级别确定，然后根据**特征重要性分数**分配给不同的**特征组**。
    *   重要特征组分配更多比特或更低的容许误差。
    *   核心目的：在保证性能的前提下，智能地在不同 Token/Layer/Head 间以及一个 Head 内部的特征间分配比特资源。

## 3. 总结：方案核心要素

1.  **多层级粒度:** 基础量化级别 (`level`) 结合 **特征组 (`group_size`)**。
2.  **特征重要性评估:** 识别并利用关键特征维度。
3.  **离群点处理:** 单独处理极端值。
4.  **特征组级归一化/标准化:** 独立的 `scale` 和 `mean`。
5.  **灵活的量化映射:** 包括均匀、正态假设以及**自适应分布量化**。
6.  **特征感知的量化策略:** 基于重要性差异化处理特征组。
7.  **(可选) 增强的动态比特分配:** 结合 Attention 和 **特征重要性**。
